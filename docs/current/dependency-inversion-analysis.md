# Dependency Inversion Analysis - FairShare App

**Date:** 2025-10-24
**Status:** Architecture Review
**Priority:** HIGH - Critical architectural gaps identified

---

## Executive Summary

This document analyzes all business logic components that the UI/presentation layer depends on, identifying concrete implementations that lack abstractions. The analysis covers **Services, Use Cases, DAOs, Providers, and all other business logic**.

### Key Findings:
- ‚úÖ **Good:** 4 repository interfaces exist (`AuthRepository`, `ExpenseRepository`, `GroupRepository`, `RemoteGroupService`)
- ‚ùå **Critical Gap:** 5 DAOs are concrete (blocks repository testing)
- ‚ùå **Critical Gap:** 11 Use Cases are concrete (blocks UI testing)
- ‚ùå **Critical Gap:** 3 Core Sync Services are concrete (blocks sync testing)
- ‚ùå **Inconsistency:** Only 1 of 3 Firestore services has an interface

**Total Components Needing Interfaces:** ~22 critical components

### üéØ Key Architectural Decisions

Based on review feedback, the following decisions have been made:

1. **‚úÖ Use Case Abstraction: Option A (Individual Interfaces)**
   - Each use case gets its own interface (e.g., `ICreateExpenseUseCase`)
   - **Rationale:** Architecturally purer, clearer semantic intent, better long-term maintainability
   - **Trade-off:** More files (11 interfaces) but significantly better code clarity

2. **‚úÖ EventBroker: Remove Singleton Pattern**
   - Remove static `_instance` and factory constructor
   - Let Riverpod manage the singleton lifecycle via provider
   - **Rationale:** Anti-pattern to have static singleton when using DI container
   - **Benefit:** Consistent with Riverpod architecture, testable, no global state pollution

---

## üî¥ CRITICAL PRIORITY - Must Add Interfaces

### 1. DAOs (Data Access Objects) - 5 Files

**Impact:** Cannot test repositories without full Drift database setup

#### Current State vs Proposed Solution

**Current:** Repositories depend on concrete DAOs
```dart
// ‚ùå Current: lib/features/expenses/data/repositories/synced_expense_repository.dart
class SyncedExpenseRepository implements ExpenseRepository {
  final AppDatabase _database;  // Exposes concrete DAOs

  @override
  Future<Result<ExpenseEntity>> createExpense(ExpenseEntity expense) async {
    // Direct dependency on concrete DAO
    await _database.expensesDao.insertExpense(expense);
  }
}

// ‚ùå Current: lib/core/database/DAOs/expenses_dao.dart
class ExpensesDao extends DatabaseAccessor<AppDatabase> {
  // Concrete Drift implementation - cannot mock
  Future<void> insertExpense(ExpenseEntity expense) { ... }
  Stream<List<ExpenseEntity>> watchExpensesByGroup(String groupId) { ... }
}
```

**Proposed:** Abstract DAOs with interfaces
```dart
// ‚úÖ Proposed: Create lib/core/database/interfaces/i_expenses_dao.dart
abstract class IExpensesDao {
  Future<void> insertExpense(ExpenseEntity expense);
  Future<ExpenseEntity?> getExpenseById(String id);
  Stream<List<ExpenseEntity>> watchExpensesByGroup(String groupId);
  Future<void> updateExpense(ExpenseEntity expense);
  Future<void> deleteExpense(String id);
  // ... all other methods
}

// ‚úÖ Proposed: Implement interface
class ExpensesDao extends DatabaseAccessor<AppDatabase> implements IExpensesDao {
  // Same implementation, now abstracted
}

// ‚úÖ Proposed: Repository depends on interface
class SyncedExpenseRepository implements ExpenseRepository {
  final IExpensesDao _expensesDao;

  SyncedExpenseRepository({required IExpensesDao expensesDao})
    : _expensesDao = expensesDao;

  @override
  Future<Result<ExpenseEntity>> createExpense(ExpenseEntity expense) async {
    await _expensesDao.insertExpense(expense);  // Now mockable!
  }
}
```

**Files Affected:**
- `lib/core/database/DAOs/expenses_dao.dart` ‚Üí Need `IExpensesDao`
- `lib/core/database/DAOs/groups_dao.dart` ‚Üí Need `IGroupsDao`
- `lib/core/database/DAOs/expense_shares_dao.dart` ‚Üí Need `IExpenseSharesDao`
- `lib/core/database/DAOs/user_dao.dart` ‚Üí Need `IUserDao`
- `lib/core/database/DAOs/sync_dao.dart` ‚Üí Need `ISyncDao`

**Benefits:**
- ‚úÖ Test repositories with mock DAOs (no database setup)
- ‚úÖ Swap database implementations (Hive, Isar, SQLite)
- ‚úÖ Follow Dependency Inversion Principle
- ‚úÖ Consistent with repository pattern you already use

---

### 2. Use Cases - 11 Files

**Impact:** Cannot mock business logic for presentation layer tests

#### Current State vs Proposed Solution

**Current:** Providers depend on concrete use cases
```dart
// ‚ùå Current: lib/features/expenses/domain/use_cases/create_expense_use_case.dart
class CreateExpenseUseCase extends UseCase<ExpenseEntity, ExpenseEntity> {
  final ExpenseRepository _repository;

  CreateExpenseUseCase(this._repository);

  @override
  Future<Result<ExpenseEntity>> execute(ExpenseEntity expense) async {
    return await _repository.createExpense(expense);
  }

  @override
  Result<void> validate(ExpenseEntity expense) {
    if (expense.amount <= 0) return Failure(Exception('Amount must be > 0'));
    return Success.unit();
  }
}

// ‚ùå Current: Providers directly use concrete classes
final createExpenseUseCase = Provider<CreateExpenseUseCase>((ref) {
  return CreateExpenseUseCase(ref.watch(expenseRepository));
});
```

**Proposed - Option A:** Individual interfaces (‚úÖ **RECOMMENDED** - Architecturally purer)
```dart
// ‚úÖ Proposed: Create lib/features/expenses/domain/interfaces/i_create_expense_use_case.dart
abstract class ICreateExpenseUseCase {
  Future<Result<ExpenseEntity>> call(ExpenseEntity expense);
}

// ‚úÖ Proposed: Implement interface
class CreateExpenseUseCase extends UseCase<ExpenseEntity, ExpenseEntity>
    implements ICreateExpenseUseCase {
  // Same implementation
}

// ‚úÖ Proposed: Provider depends on interface (Clear semantic intent!)
final createExpenseUseCase = Provider<ICreateExpenseUseCase>((ref) {
  return CreateExpenseUseCase(ref.watch(expenseRepository));
});
```

**Why Option A is Better:**
- ‚úÖ **Clear semantic intent:** `ICreateExpenseUseCase` is explicit about behavior
- ‚úÖ **Better DI:** Dependencies declare *what* they do, not just types
- ‚úÖ **Better long-term:** Easier to understand code 6 months later
- ‚úÖ **IDE support:** Better autocomplete and navigation
- ‚ö†Ô∏è **Trade-off:** More interfaces (11 files), but the clarity is worth it

**Proposed - Option B:** Generic interface (Simpler, less boilerplate)
```dart
// ‚úÖ Proposed: Update lib/core/domain/use_case.dart
abstract class IUseCase<Input, Output> {
  Future<Result<Output>> call(Input input);
}

// ‚úÖ Proposed: Base class implements interface
abstract class UseCase<Input, Output> implements IUseCase<Input, Output> {
  @override
  Future<Result<Output>> call(Input input) async {
    final validationResult = validate(input);
    if (validationResult.isError()) return validationResult.toFailure();
    return await execute(input);
  }

  Result<void> validate(Input input) => Success.unit();
  Future<Result<Output>> execute(Input input);
}

// ‚úÖ Proposed: Providers use generic interface
final createExpenseUseCase = Provider<IUseCase<ExpenseEntity, ExpenseEntity>>((ref) {
  return CreateExpenseUseCase(ref.watch(expenseRepository));
});
```

**Why Option B is Less Ideal:**
- ‚úÖ **Pro:** Simple, one interface to rule them all
- ‚úÖ **Pro:** Less boilerplate (no 11 interface files)
- ‚ùå **Con:** Less semantically clear - "thing that takes Expense and returns Expense"
- ‚ùå **Con:** Harder to read: What does `IUseCase<ExpenseEntity, ExpenseEntity>` do?
- ‚ö†Ô∏è **Trade-off:** Simpler but sacrifices clarity

**Final Recommendation:** **Go with Option A** for architectural purity and better long-term maintainability.

**Files Affected:**

**Expense Use Cases:**
- `create_expense_use_case.dart`
- `update_expense_use_case.dart`
- `delete_expense_use_case.dart`
- `get_expense_use_case.dart`
- `get_expenses_by_group_use_case.dart`

**Group Use Cases:**
- `create_group_use_case.dart`
- `update_group_use_case.dart`
- `delete_group_use_case.dart`
- `add_member_use_case.dart`
- `remove_member_use_case.dart`
- `join_group_by_code_use_case.dart`

**Benefits:**
- ‚úÖ Test notifiers/ViewModels with mock use cases
- ‚úÖ Add decorators: `LoggingUseCase`, `CachedUseCase`, `RetryUseCase`
- ‚úÖ Follow Open/Closed Principle
- ‚úÖ Consistent with repository abstraction pattern

---

### 3. Core Sync Services - 3 Files

**Impact:** Cannot test sync architecture without live Firestore

#### Current State vs Proposed Solution

**Current:** Concrete sync services
```dart
// ‚ùå Current: lib/core/sync/sync_service.dart
class SyncService with LoggerMixin, WidgetsBindingObserver {
  final UploadQueueService _uploadQueueService;
  final RealtimeSyncService _realtimeSyncService;
  // Concrete dependencies

  void startAutoSync(String? userId) {
    _uploadQueueService.processQueue();
    _realtimeSyncService.startRealtimeSync(userId);
  }
}

// ‚ùå Current: Providers expose concrete classes
final syncService = Provider<SyncService>((ref) {
  return SyncService(
    database: ref.watch(appDatabase),
    uploadQueueService: ref.watch(uploadQueueService),
    // ...
  );
});
```

**Proposed:** Abstract with interfaces
```dart
// ‚úÖ Proposed: Create lib/core/sync/interfaces/i_sync_service.dart
abstract class ISyncService {
  void startAutoSync(String? userId);
  void stopAutoSync();
  Future<Result<void>> syncAll(String userId);
  Future<int> getPendingUploadCount();
  Map<String, dynamic> getSyncStatus();
  void dispose();
}

// ‚úÖ Proposed: Create lib/core/sync/interfaces/i_upload_queue_service.dart
abstract class IUploadQueueService {
  Future<UploadQueueResult> processQueue();
  Future<int> getPendingCount();
}

// ‚úÖ Proposed: Create lib/core/sync/interfaces/i_realtime_sync_service.dart
abstract class IRealtimeSyncService {
  Future<void> startRealtimeSync(String userId);
  Future<void> stopRealtimeSync();
  void listenToActiveGroup(String groupId);
  void stopListeningToActiveGroup();
  Map<String, dynamic> getStatus();
}

// ‚úÖ Proposed: Implementations
class SyncService with LoggerMixin, WidgetsBindingObserver implements ISyncService {
  // Same implementation
}

// ‚úÖ Proposed: Providers use interfaces
final syncService = Provider<ISyncService>((ref) {
  return SyncService(/* ... */);
});
```

**Files Affected:**
- `lib/core/sync/sync_service.dart`
- `lib/core/sync/upload_queue_service.dart`
- `lib/core/sync/realtime_sync_service.dart`

**Benefits:**
- ‚úÖ Test presentation layer without Firestore
- ‚úÖ Mock sync behavior for offline testing
- ‚úÖ Enable alternative sync strategies
- ‚úÖ Isolate sync logic from infrastructure

---

### 4. Firestore Services - 2 Files (Missing Interfaces)

**Impact:** Inconsistent abstraction, sync services tightly coupled to Firestore

#### Current State vs Proposed Solution

**Current:** Only groups have interface, expenses and users don't
```dart
// ‚úÖ Already exists: lib/features/groups/domain/services/remote_group_service.dart
abstract class RemoteGroupService {
  Future<Result<void>> uploadGroup(GroupEntity group);
  Future<Result<GroupEntity>> downloadGroup(String groupId);
  // ... other methods
}

// ‚ùå Current: No interface for expenses
// lib/features/expenses/data/services/firestore_expense_service.dart
class FirestoreExpenseService with LoggerMixin {
  final FirebaseFirestore _firestore;

  Future<Result<void>> uploadExpense(ExpenseEntity expense) { ... }
  Stream<List<ExpenseEntity>> watchGroupExpenses(String groupId) { ... }
}

// ‚ùå Current: UploadQueueService depends on concrete class
class UploadQueueService {
  final FirestoreExpenseService _expenseService;  // Concrete!

  Future<void> _processExpenseOperation(SyncQueueData operation) async {
    await _expenseService.uploadExpense(expense);  // Cannot mock
  }
}
```

**Proposed:** Match the groups pattern
```dart
// ‚úÖ Proposed: Create lib/features/expenses/domain/services/remote_expense_service.dart
abstract class RemoteExpenseService {
  Future<Result<void>> uploadExpense(ExpenseEntity expense);
  Future<Result<void>> uploadExpenseShare(ExpenseShareEntity share);
  Future<Result<ExpenseEntity>> downloadExpense(String groupId, String expenseId);
  Future<Result<List<ExpenseEntity>>> downloadGroupExpenses(String groupId);
  Future<Result<List<ExpenseShareEntity>>> downloadExpenseShares(String groupId, String expenseId);
  Future<Result<void>> deleteExpense(String groupId, String expenseId);
  Stream<List<ExpenseEntity>> watchGroupExpenses(String groupId);
  Stream<ExpenseEntity> watchExpense(String groupId, String expenseId);
  Stream<List<ExpenseShareEntity>> watchExpenseShares(String groupId, String expenseId);
}

// ‚úÖ Proposed: Implement interface
class FirestoreExpenseService with LoggerMixin implements RemoteExpenseService {
  // Same implementation
}

// ‚úÖ Proposed: Create lib/features/auth/domain/services/remote_user_service.dart
abstract class RemoteUserService {
  Future<Result<void>> uploadUser(User user);
  Future<Result<User>> downloadUser(String userId);
  Stream<User> watchUser(String userId);
}

// ‚úÖ Proposed: UploadQueueService depends on interface
class UploadQueueService {
  final RemoteExpenseService _expenseService;  // Now mockable!
}
```

**Files Affected:**
- `lib/features/expenses/data/services/firestore_expense_service.dart`
- `lib/features/auth/data/services/firestore_user_service.dart`

**Benefits:**
- ‚úÖ Consistent pattern across all remote services
- ‚úÖ Test sync services without Firestore
- ‚úÖ Enable alternative backends (REST, GraphQL)
- ‚úÖ Match existing `RemoteGroupService` pattern

---

### 5. GroupInitializationService - 1 File

**Impact:** Cannot test `SyncService.startAutoSync()` without side effects

#### Current State vs Proposed Solution

**Current:** Concrete service with side effects
```dart
// ‚ùå Current: lib/features/groups/data/services/group_initialization_service.dart
class GroupInitializationService with LoggerMixin {
  final GroupRepository _repository;

  Future<void> ensurePersonalGroupExists(String userId) async {
    try {
      await _repository.getGroupById(userId);
    } catch (e) {
      await _createPersonalGroup(userId);  // Side effect!
    }
  }
}

// ‚ùå Current: SyncService depends on concrete class
class SyncService {
  final GroupInitializationService _groupInitializationService;

  void startAutoSync(String? userId) {
    _groupInitializationService.ensurePersonalGroupExists(userId);
    // Cannot test without creating actual group!
  }
}
```

**Proposed:** Abstract with interface
```dart
// ‚úÖ Proposed: Create lib/features/groups/domain/services/i_group_initialization_service.dart
abstract class IGroupInitializationService {
  Future<void> ensurePersonalGroupExists(String userId);
}

// ‚úÖ Proposed: Implement interface
class GroupInitializationService with LoggerMixin
    implements IGroupInitializationService {
  // Same implementation
}

// ‚úÖ Proposed: SyncService depends on interface
class SyncService {
  final IGroupInitializationService _groupInitializationService;
  // Now mockable!
}
```

**Files Affected:**
- `lib/features/groups/data/services/group_initialization_service.dart`

**Benefits:**
- ‚úÖ Test SyncService without database side effects
- ‚úÖ Mock group initialization behavior
- ‚úÖ Simple to implement (single method)

---

## üü° MEDIUM PRIORITY - Should Add Interfaces

### 6. EventBroker - 1 File

**Impact:** Hard to verify event flows in tests

#### Current State vs Proposed Solution

**Current:** Concrete singleton (Anti-pattern with Riverpod!)
```dart
// ‚ùå Current: lib/core/events/event_broker.dart
class EventBroker {
  static final EventBroker _instance = EventBroker._internal();  // ‚ùå Anti-pattern!
  factory EventBroker() => _instance;

  final _controller = StreamController<AppEvent>.broadcast();

  void fire(AppEvent event) => _controller.add(event);
  Stream<T> on<T extends AppEvent>() => _controller.stream.where((e) => e is T).cast<T>();
}

// ‚ùå Current: Cannot verify events in tests
class SyncedExpenseRepository {
  final EventBroker _eventBroker;

  Future<Result<ExpenseEntity>> createExpense(ExpenseEntity expense) async {
    await _expensesDao.insertExpense(expense);
    _eventBroker.fire(ExpenseCreated(expense));  // Cannot verify!
  }
}
```

**Why Current is Anti-Pattern:**
- ‚ùå **Riverpod IS your service locator** - using static singleton bypasses DI
- ‚ùå **Cannot mock in tests** - static instance always returns real broker
- ‚ùå **Global state pollution** - singleton persists across tests
- ‚ùå **Pattern inconsistency** - other services use Riverpod, EventBroker doesn't

**Proposed:** Abstract with interface AND remove singleton pattern
```dart
// ‚úÖ Proposed: Create lib/core/events/i_event_broker.dart
abstract class IEventBroker {
  void fire(AppEvent event);
  Stream<T> on<T extends AppEvent>();
  void dispose();
}

// ‚úÖ Proposed: Remove static singleton, implement interface
class EventBroker implements IEventBroker {
  // NO static instance, NO private constructor, NO factory
  final _controller = StreamController<AppEvent>.broadcast();

  void fire(AppEvent event) => _controller.add(event);
  Stream<T> on<T extends AppEvent>() => _controller.stream.where((e) => e is T).cast<T>();
  void dispose() => _controller.close();
}

// ‚úÖ Proposed: Riverpod manages the singleton (already exists, just update type)
// lib/core/events/event_providers.dart
final eventBrokerProvider = Provider<IEventBroker>((ref) {
  final broker = EventBroker();  // Riverpod manages lifecycle
  ref.onDispose(() => broker.dispose());
  return broker;
});

// ‚úÖ Proposed: Repository depends on interface
class SyncedExpenseRepository {
  final IEventBroker _eventBroker;

  Future<Result<ExpenseEntity>> createExpense(ExpenseEntity expense) async {
    await _expensesDao.insertExpense(expense);
    _eventBroker.fire(ExpenseCreated(expense));

    // ‚úÖ In tests: verify(mockEventBroker.fire(any));
  }
}
```

**Why This is Better:**
- ‚úÖ **Riverpod manages singleton** - consistent with your architecture
- ‚úÖ **Mockable in tests** - provider can be overridden
- ‚úÖ **No global state** - each test gets fresh broker via ProviderContainer
- ‚úÖ **Proper disposal** - Riverpod handles lifecycle
- ‚úÖ **Pattern consistency** - matches how you use other services

**Files Affected:**
- `lib/core/events/event_broker.dart`

**Benefits:**
- ‚úÖ Verify event firing in tests
- ‚úÖ Mock event subscribers
- ‚úÖ Enable alternative event bus implementations
- ‚úÖ Test event-driven flows in isolation

---

## üü¢ LOW PRIORITY - Acceptable As-Is

### 7. BalanceCalculationService

**Status:** ‚úÖ Pure business logic, no external dependencies
```dart
// ‚úÖ Current: Already testable
class BalanceCalculationService {
  Map<String, double> calculateNetBalances(
    List<GroupMemberEntity> members,
    List<ExpenseEntity> expenses,
    List<ExpenseShareEntity> shares,
  ) {
    // Pure calculation - easy to test
  }
}
```

**Recommendation:** Interface optional, current implementation acceptable

---

### 8. Formatters & Converters

**Status:** ‚úÖ Pure utility functions
```dart
// ‚úÖ Current: Already testable
class ExpenseFormatter {
  static String formatAmount(double amount) { ... }
  static String formatDate(DateTime date) { ... }
}
```

**Recommendation:** No interface needed

---

### 9. Monitoring & Logging

**Status:** ‚úÖ Infrastructure singletons
```dart
// ‚úÖ Current: Acceptable pattern
class SyncMetrics {
  static final instance = SyncMetrics._();
  void recordSyncSuccess() { ... }
}
```

**Recommendation:** Standard pattern, no interface needed

---

### 10. Providers/Notifiers

**Status:** ‚úÖ Riverpod handles testing
```dart
// ‚úÖ Current: Testable with ProviderContainer
class AuthNotifier extends _$AuthNotifier {
  Future<void> signInWithGoogle() { ... }
}

// ‚úÖ Test without interface:
final container = ProviderContainer(overrides: [
  authNotifierProvider.overrideWith(() => MockAuthNotifier()),
]);
```

**Recommendation:** Riverpod's design handles this, interface optional

---

### 11. Entities & Value Objects

**Status:** ‚úÖ Pure data models (Freezed)
```dart
// ‚úÖ Current: Correct pattern
@freezed
class ExpenseEntity with _$ExpenseEntity {
  const factory ExpenseEntity({ ... }) = _ExpenseEntity;
}
```

**Recommendation:** Entities should remain concrete

---

## üìä Comprehensive Criticality Matrix

| Component | Files | Priority | Testing Impact | Interfaces Needed |
|-----------|-------|----------|----------------|-------------------|
| **DAOs** | 5 | üî¥ CRITICAL | Cannot test repos | 5 |
| **Use Cases** | 11 | üî¥ CRITICAL | Cannot mock for UI | 11 (or 1 generic) |
| **Sync Services** | 3 | üî¥ CRITICAL | Cannot test sync | 3 |
| **Firestore Services** | 2 | üî¥ CRITICAL | Inconsistent pattern | 2 |
| **GroupInitService** | 1 | üî¥ CRITICAL | Blocks testing | 1 |
| **EventBroker** | 1 | üü° MEDIUM | Hard to verify | 1 |
| **Notifiers** | ~10 | üü° MEDIUM | Riverpod handles | 0 (optional) |
| **BalanceCalcService** | 1 | üü¢ LOW | Already testable | 0 (optional) |
| **Formatters** | 2 | üü¢ LOW | Pure functions | 0 |
| **Metrics/Logging** | 2 | üü¢ LOW | Infrastructure | 0 |
| **Entities** | ~10 | üü¢ LOW | Data models | 0 |

**Total Interfaces Needed:**
- **Critical:** 22 interfaces (using individual use case interfaces - Option A)
- **Optional:** 1-2 interfaces (EventBroker, others)

**Note:** We're going with Option A (individual use case interfaces) for semantic clarity and long-term maintainability.

---

## üéØ Implementation Roadmap

### Phase 1: Foundation (Highest ROI) - 2-3 Days
**Goal:** Enable repository and sync testing

1. ‚úÖ Create DAO interfaces (5 interfaces)
   - `IExpensesDao`, `IGroupsDao`, `IExpenseSharesDao`, `IUserDao`, `ISyncDao`
   - Update repositories to depend on interfaces
   - Update `AppDatabase` to return interfaces
   - **Files:** ~15 modified

2. ‚úÖ Create Firestore service interfaces (2 interfaces)
   - `RemoteExpenseService`, `RemoteUserService`
   - Match existing `RemoteGroupService` pattern
   - **Files:** ~8 modified

3. ‚úÖ Create Sync service interfaces (3 interfaces)
   - `ISyncService`, `IUploadQueueService`, `IRealtimeSyncService`
   - Update providers to use interfaces
   - **Files:** ~10 modified

**Deliverable:** Can test entire data and sync layers with mocks

---

### Phase 2: Use Case Abstraction - 1-2 Days
**Goal:** Enable presentation layer testing

4. ‚úÖ Create use case interfaces (**Use Option A - Individual Interfaces**)
   - **RECOMMENDED:** 11 individual interfaces (e.g., `ICreateExpenseUseCase`)
   - Provides clear semantic intent and better long-term maintainability
   - Update providers to depend on interfaces
   - **Files:** ~25 modified

5. ‚úÖ Create `IGroupInitializationService` interface
   - **Files:** ~3 modified

**Deliverable:** Can test notifiers/ViewModels with mock business logic

---

### Phase 3: Event System Refinement - 0.5-1 Day
**Goal:** Better event testing and proper DI pattern

6. ‚úÖ Create `IEventBroker` interface AND remove singleton pattern
   - Enable event verification in tests
   - Remove static `_instance` and let Riverpod manage lifecycle
   - Update `eventBrokerProvider` to return `IEventBroker`
   - **Files:** ~15 modified (many components use EventBroker)
   - **IMPORTANT:** This fixes an anti-pattern (static singleton + DI container)

**Deliverable:** Can verify event flows in tests + proper Riverpod pattern

---

### Phase 4: Optional Refinements - 1-2 Days
**Goal:** Architectural perfectionism

7. üîò Abstract notifiers if desired (optional)
8. üîò Add use case decorators (logging, caching, analytics)
9. üîò Consider interface for `BalanceCalculationService` for DDD purity

**Deliverable:** Ultra-clean architecture

---

## üìà Estimated Effort

| Phase | Files | Effort | ROI |
|-------|-------|--------|-----|
| Phase 1 | ~33 | 2-3 days | üî• Very High |
| Phase 2 | ~28 | 1-2 days | üî• High |
| Phase 3 | ~15 | 0.5-1 day | üî• Medium |
| Phase 4 | ~15 | 1-2 days | üî• Low |
| **TOTAL** | **~91** | **4-8 days** | - |

---

## üèÜ What You're Already Doing Right

Your codebase demonstrates excellent architecture in several areas:

‚úÖ **Repository Pattern:** `ExpenseRepository`, `GroupRepository`, `AuthRepository` (interfaces + implementations)
‚úÖ **One Firestore Interface:** `RemoteGroupService` ‚Üí `FirestoreGroupService`
‚úÖ **Use Case Base Class:** `UseCase<Input, Output>` abstract pattern
‚úÖ **Event-Driven Architecture:** Domain events with `EventBroker`
‚úÖ **User-Scoped Dependencies:** Prevents data leakage in multi-user scenarios
‚úÖ **Clean Domain Entities:** Immutable Freezed models
‚úÖ **Result Type Wrapping:** Functional error handling with `Result<T>`
‚úÖ **Offline-First:** Local database as source of truth

---

## ‚ùå Critical Architectural Gaps

### Current Issues:

1. **DAOs are concrete**
   - Biggest DIP violation
   - Repositories tightly coupled to Drift
   - Cannot test repositories without full database

2. **Use cases are concrete**
   - Presentation layer tightly coupled to business logic
   - Cannot mock use cases for UI tests
   - Cannot add decorators for cross-cutting concerns

3. **Sync services are concrete**
   - Core architecture tightly coupled to Firestore
   - Cannot test sync flows without live backend
   - Cannot swap sync strategies

4. **Inconsistent Firestore abstraction**
   - Groups have interface, expenses and users don't
   - Pattern inconsistency across features
   - Some services mockable, others not

5. **EventBroker is concrete singleton**
   - Hard to verify event flows in tests
   - Cannot mock event system
   - Testing event-driven behavior requires real broker
   - **Anti-pattern:** Static singleton when using Riverpod DI container

### Consequences:

- üö´ **High coupling to Drift** - Cannot swap database
- üö´ **High coupling to Firestore** - Cannot swap backend
- üö´ **Difficult to test** - Most layers require full infrastructure
- üö´ **Cannot swap implementations** - Locked into tech stack
- üö´ **Violates SOLID principles** - Dependency Inversion violated

---

## üí° Benefits of Proposed Changes

### Testing Benefits:
- ‚úÖ Unit test repositories without database
- ‚úÖ Unit test use cases in isolation
- ‚úÖ Unit test presentation layer with mocks
- ‚úÖ Verify event flows in tests
- ‚úÖ Test sync logic without Firestore

### Architecture Benefits:
- ‚úÖ Follow Dependency Inversion Principle
- ‚úÖ Enable alternative implementations
- ‚úÖ Add decorators for cross-cutting concerns
- ‚úÖ Consistent abstraction patterns
- ‚úÖ Loose coupling between layers

### Maintenance Benefits:
- ‚úÖ Easier to refactor implementations
- ‚úÖ Technology stack flexibility
- ‚úÖ Better separation of concerns
- ‚úÖ Clearer architectural boundaries
- ‚úÖ Future-proof design

---

## üìù Next Steps

### Immediate Actions (Recommended):
1. **Review this analysis** with the team
2. **Prioritize Phase 1** (DAOs + Firestore + Sync services)
3. **Create feature branch** for abstraction work
4. **Start with DAOs** (highest impact, foundational)

### Discussion Points:
- ‚úÖ **DECIDED:** Use Option A (individual use case interfaces) for semantic clarity
- ‚úÖ **DECIDED:** Remove EventBroker static singleton, let Riverpod manage lifecycle
- Should we tackle all phases or just Phase 1-2?
- What's our testing strategy once interfaces exist?
- Do we want to add use case decorators (logging, analytics) in Phase 4?

### Success Criteria:
- [ ] All repositories testable without database
- [ ] All use cases mockable for UI tests
- [ ] Sync services testable without Firestore
- [ ] Consistent abstraction patterns across features
- [ ] 80%+ unit test coverage enabled

---

## üîó Related Documentation

- [Architecture Overview](./architecture-overview.md)
- [Testing Strategy](./testing-strategy.md)
- [Sync Architecture](./sync-architecture.md)
- [Repository Pattern](./repository-pattern.md)

---

**Document Owner:** Architecture Team
**Last Updated:** 2025-10-24
**Next Review:** After Phase 1 implementation
